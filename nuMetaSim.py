"""
Function:    Generate non-uniform simulated sequencing single-end reads
"""

import os
import numpy as np
import random
import re
from optparse import OptionParser 

tot_weighted_genome_length = 0          # global weighted genome length, used to normalize the proportion
visible_accurate_rate = np.array([])    # accurate rate before transforming sequencing image to sequences


def argvParse():
    # parse input parameters
    usageReminder = ("usage: python NonSIM.py [--index] index_file [--propor] propor_table\n"
                     "[-F] file_name_write [-n] read_number [-L] read_length\n"
                     "[-v] var_seed_flag [-r] random_seed [-b] bin_size\n"
                     "[--dis_flag] distribution_use_flag [--distri] distribution_table\n"
                     "[--builtin_distri] distribution_name [--builtin_distri_args] distribution_args\n"
                     "[--fa_fq_flag] fasta_fastq_flag [--qual] quality_score_table\n"
                     "[--err_adj_flag] error_adjust_flag [--err_rate] error_rate\n"
                     "[--h_flag] human_flag [--h_ref_dir] human_ref_folder\n"
                     "[--h_ratio] human_ratio [--h_index] human_index [--h_propor] human_propor_table\n"
                     "[--unk_flag] unknown_flag [--unk_ref_dir] unknown_ref_folder\n"
                     "[--unk_ratio] unknown_ratio [--unk_index] unknown_index [--unk_propor] unknown_propor_table")
    parser = OptionParser(usage = usageReminder)
    parser.add_option("--index", action = "store", type = "string", dest = "index_file", \
                      help = ("An index file generated by \"microbe_index.py\" containing the information about "
                              "the accession number (new NCBI form started from Sep. 2016, not gi number), "
                              "genome length, genome name and genome storage path. This file must be provided."))
    parser.add_option("--propor", action = "store", type = "string", dest = "propor_table", \
                      help = ("A tab-delimited proportion table that is the list of the relative abundance "
                              "of each reference genome to be simulated. Each line contains a genome name and a "
                              "relative abundance number. Every genome name must be the same with the index file\'s "
                              "genome name, and the sum of all the relative abundance should be 1."))
    parser.add_option("-F", action = "store", type = "string", dest = "file_name_write", \
                      help = ("The prefix name of the simulated data to be generated, no suffix is needed. For example, "
                              "If a user inputs \"sample\" to this parameter, the name of the generated data will be "
                              "\"sample.fa\" or \"sample.fq\"."))
    parser.add_option("-n", action = "store", type = "int", dest = "read_number", \
                      help = "Total read number.")
    parser.add_option("-L", action = "store", type = "int", dest = "read_length", \
                      help = "Read length.")
    parser.add_option("-v", action = "store", type = "int", dest = "var_seed_flag", \
                      help = ("A 0-1 flag to control whether to use a variable random seed each running time. 0 means "
                              "fixed random seed (should be set by the user), 1 means variable random seed. Default is 0."))
    parser.add_option("-r", action = "store", type = "int", dest = "random_seed", \
                      help = "Random seed, only works when the \"var_seed_flag\" is set be 0. Default random_seed is 0.")
    parser.add_option("-b", action = "store", type = "int", dest = "bin_size", \
                      help = "Bin size, only works when the user choose to use th built-in distribution. Default is 2000.")    
    parser.add_option("--dis_flag", action = "store", type = "int", dest = "distribution_use_flag", \
                      help = ("A 0-1 flag to control whether to use the built-in distribution or the user-input "
                              "distribution table. 0 means built-in distribution will be used, 1 means user-input "
                              "distribution table will be used. Default is 0."))
    parser.add_option("--distri", action = "store", type = "string", dest = "distribution_table", \
                      help = ("A distribution table realizing the non-uniform sampling. It can be generated by "
                              "tool scripts along with NonSIM such as \"cal_genome_distribution_by_GC.py\" and "
                              "\"cal_genome_distribution_step.py\", or manually designed by the user."))
    parser.add_option("--builtin_distri", action = "store", type = "int", dest = "distribution_name", \
                      help = ("Built-in distribution seletion, only works when \"dis_flag\" is set to be 0. "
                              "Three options: 1 means uniform, 2 means normal, 3 means exponential. Default is 1."))
    parser.add_option("--builtin_distri_args", action = "store", type = "string", dest = "distribution_args", \
                      help = ("Built-in distribution parameters, only works when \"dis_flag\" is set to be 0. "
                              "For uniform distribution (1), the input format should be like this \"0,1\". "
                              "For normal distribution (2), the input format should be like this \"0,1\". "
                              "For exponential distribution (3), the input format should be like this \"1\"."))
    parser.add_option("--fa_fq_flag", action = "store", type = "int", dest = "fasta_fastq_flag", \
                      help = ("A 0-1 flag to control whether to generate fasta format data or fastq format data. "
                              "0 means fasta, 1 means fastq. Default is 0."))
    parser.add_option("--qual", action = "store", type = "string", dest = "quality_score_table", \
                      help = ("A quality score distribution table extracted from real sequencing data with quality scores. "
                              "This input file can be generated by\"extract_quality_score_distribution.py\"."))
    parser.add_option("--err_adj_flag", action = "store", type = "int", dest = "error_adjust_flag", \
                      help = ("A 0-1 flag to control whether to adjust the error probability derived from quality scores "
                              "according to the error rate or not. 1 means adjustment will be operated, 0 means the "
                              "opposite, that is to directly use the error probability derived from quality scores. In the "
                              "latter way, the base error rate cannot be controlled. Default is 0."))
    parser.add_option("--err_rate", action = "store", type = "float", dest = "error_rate", \
                      help = ("Overall base error rate, only works when \"err_adj_flag\" is set to be 1. Default is 0.001. "
                              "The \"--err_rate\" parameter cannot be set higher than 1.0. The recommended range "
                              "is 0.001 to 0.05."))
    parser.add_option("--h_flag", action = "store", type = "int", dest = "human_flag", \
                      help = ("A 0-1 flag to control whether to add human reads to the data or not. 0 means do not add "
                              "human reads, 1 means add human reads. Default is 0."))
    parser.add_option("--h_ref_dir", action = "store", type = "string", dest = "human_ref_folder", \
                      help = ("A folder contains all the human reference sequence. The \"--h_ref_dir\" parameter should be "
                              "the folder's path."))
    parser.add_option("--h_ratio", action = "store", type = "float", dest = "human_ratio", \
                      help = "Human reads ratio, only works when \"h_flag\" is set to be 1. Default is 0.01.")
    parser.add_option("--h_index", action = "store", type = "string", dest = "human_index", \
                      help = ("Human reference sequence index, similar with microbial index, but only contains three columns, "
                              "which are sequence name, sequence length and storage path."))
    parser.add_option("--h_propor", action = "store", type = "string", dest = "human_propor_table", \
                      help = ("A tab-delimited proportion table of all the reference human sequence. The format and "
                              "requirement is the same with the microbial proportion table. This table is unnecessary, "
                              "only needed if a user wants to control the abundance of each used human reference sequence, "
                              "otherwise all the abundance will be automatically set to an equal number (human_ratio / human_ref_seq_num)"))
    parser.add_option("--unk_flag", action = "store", type = "int", dest = "unknown_flag", \
                      help = ("A 0-1 flag to control whether to add unknown reads to the data or not. 0 means do not add "
                              "unknown reads, 1 means add unknown reads. Default is 0."))
    parser.add_option("--unk_ref_dir", action = "store", type = "string", dest = "unknown_ref_folder", \
                      help = ("A folder contains all the unknown reference sequence. The \"--unk_ref_dir\" parameter "
                              "should be the folder's path."))
    parser.add_option("--unk_ratio", action = "store", type = "float", dest = "unknown_ratio", \
                      help = "Unknown reads ratio, only works when \"unk_flag\" is set to be 1. Default is 0.01.")
    parser.add_option("--unk_index", action = "store", type = "string", dest = "unknown_index", \
                      help = ("Unknown reference sequence index, similar with microbial index, but only contains three columns, "
                              "which are sequence name, sequence length and storage path."))
    parser.add_option("--unk_propor", action = "store", type = "string", dest = "unknown_propor_table", \
                      help = ("Similar with human proportion table, introduction omitted."))
    (opts, args) = parser.parse_args()
    return opts

def argvCheck(opts):
    # check input parameters

    def check_index(file_name):
        # check genome index
        genome_names = {}
        try:
            with open(file_name) as f_r:
                for line in f_r:
                    genome_name = line.strip().split('\t')[2]
                    genome_names[genome_name] = None
        except:
            print "Index file cannot be opened or found! please double check your input."
            os._exit(1)
        return genome_names

    def check_propor_table(file_name, genome_names):
        # check microbial proportion table
        name_not_included = []
        count = 0
        propor_sum = 0.0
        threshold = 1e-6
        try:
            with open(file_name) as f_r:
                for line in f_r:
                    count += 1
                    terms = line.strip().split('\t')
                    genome_name, abundance = terms[0], np.float(terms[1])
                    propor_sum += abundance
                    if not genome_names.has_key(genome_name):
                        name_not_included.append(genome_name)
            if count != len(genome_names):
                print ("The number of genome names in the microbial proportion table is not equal to the number of "
                       "genome names in the index file. Please double check your microbial proportion table. "
                       "Program will exit.")
                os._exit(1)
            if len(name_not_included) > 0:
                print ("The following genome names are not included in the index file. Please double check your "
                       "microbial proportion table. Program will exit.")
                for term in name_not_included:
                    print term
                os._exit(1)
            if np.abs(propor_sum - 1.0) > threshold:
                print ("Sum of all the relative abundance does not equal to 1. Please double check your "
                       "microbial proportion table. Program will exit.")
                os._exit(1)
        except:
            print "Microbial proportion table cannot be opened or found! please double check your input."
            os._exit(1)

    def check_distri_table(file_name, genome_names):
        # check genome distribution table
        name_not_included = []
        count = 0
        try:
            with open(file_name) as f_r:
                for line in f_r:
                    count += 1
                    genome_name = line.strip().split('\t')[0]
                    if not genome_names.has_key(genome_name):
                        name_not_included.append(genome_name)
            if count != len(genome_names):
                print ("The number of genome names in the distribution table is not equal to the number of "
                       "genome names in the index file. Please double check your distribution table. "
                       "Program will exit.")
                os._exit(1)
            if len(name_not_included) > 0:
                print ("The following genome names are not included in the index file. Please double check your "
                       "distribution table. Program will exit.")
                for term in name_not_included:
                    print term
                os._exit(1)
        except:
            print "Distribution table cannot be opened or found! please double check your input."
            os._exit(1)

    def check_humanOrUnknown_index(file_name):
        # check human (or unknown) genome index
        genome_names = {}
        try:
            with open(file_name) as f_r:
                for line in f_r:
                    genome_name = line.strip().split('\t')[0]
                    genome_names[genome_name] = None
        except:
            print "Human (or unknown) index file cannot be opened or found! please double check your input."
            os._exit(1)
        return genome_names

    def check_humanOrUnknown_propor_table(file_name, genome_names):
        # check human (or unknown) proportion table
        name_not_included = []
        count = 0
        propor_sum = 0.0
        threshold = 1e-6
        try:
            with open(file_name) as f_r:
                for line in f_r:
                    count += 1
                    terms = line.strip().split('\t')
                    genome_name, abundance = terms[0], np.float(terms[1])
                    propor_sum += abundance
                    if not genome_names.has_key(genome_name):
                        name_not_included.append(genome_name)
            if count != len(genome_names):
                print ("The number of sequence names in the human (or unknown) proportion table is not equal "
                       "to the number of sequence names in the index file. Please double check your human (or unknown) "
                       "proportion table. Program will exit.")
                os._exit(1)
            if len(name_not_included) > 0:
                print ("The following sequence names are not included in the index file. Please double check your "
                       "human (or unknown) proportion table. Program will exit.")
                for term in name_not_included:
                    print term
                os._exit(1)
            if np.abs(propor_sum - 1.0) > threshold:
                print ("Sum of all the relative abundance does not equal to 1. Please double check your "
                       "human (or unknown) proportion table. Program will exit.")
                os._exit(1)
        except:
            print "Human (or unknown) proportion table cannot be opened or found! please double check your input."
            os._exit(1)

    # check the necessary parameters, if anyone of them is missing, the program will exit
    if opts.index_file == None or opts.propor_table == None or opts.file_name_write == None or \
       opts.read_number == None or opts.read_length == None:
        print ("At least one of the necessary parameters (--index, --propor, -F, -n, -L) is missing! "
               "Please double check your input. Program will exit.")
        os._exit(1)
    # check index file
    genome_names = check_index(opts.index_file)
    # check microbial proportion table
    check_propor_table(opts.propor_table, genome_names)
    # check variable seed flag
    if opts.var_seed_flag == None or opts.var_seed_flag == 0:
        opts.var_seed_flag = 0
        if opts.random_seed == None:
            opts.random_seed = 0
    elif opts.var_seed_flag != None and opts.var_seed_flag != 0 and opts.var_seed_flag != 1:
        print "Incorrect input! The \"-v\" parameter only accepts the input 0 or 1. Program will exit."
        os._exit(1)
    # check distribution use flag
    if opts.distribution_use_flag == None or opts.distribution_use_flag == 0:
        opts.distribution_use_flag = 0
        if opts.bin_size == None:
            opts.bin_size = 2000
        if opts.distribution_name == None or opts.distribution_name == 1:
            opts.distribution_name = np.random.uniform
        elif opts.distribution_name == 2:
            opts.distribution_name = np.random.normal
        elif opts.distribution_name == 3:
            opts.distribution_name = np.random.exponential
        elif opts.distribution_name != None and opts.distribution_name != np.random.uniform and \
             opts.distribution_name != np.random.normal and opts.distribution_name != np.random.exponential:
            print "Incorrect input! The \"--builtin_distri\" parameter only accepts the input 1 or 2 or 3. Program will exit."
            os._exit(1)      
        if opts.distribution_args != None:
            if type(opts.distribution_args) != list:
                p = re.compile(r'-?[0-9]+\.?[0-9]*')
                tmp_list = p.findall(opts.distribution_args)
                opts.distribution_args = [float(term) for term in tmp_list]
        elif opts.distribution_args == None:
            if opts.distribution_name == np.random.uniform:
                opts.distribution_args = [0, 1]
            elif opts.distribution_name == np.random.normal:
                opts.distribution_args = [0, 1]
            elif opts.distribution_name == np.random.exponential:
                opts.distribution_args = [1]
    elif opts.distribution_use_flag == 1:
        check_distri_table(opts.distribution_table, genome_names)
    elif opts.distribution_use_flag != 0 and opts.distribution_use_flag != 1:
        print "Incorrect input! The \"--dis_flag\" parameter only accepts the input 0 or 1. Program will exit."
        os._exit(1)
    # check fasta or fastq flag
    if opts.fasta_fastq_flag == None or opts.fasta_fastq_flag == 0:
        opts.fasta_fastq_flag = 0
    elif opts.fasta_fastq_flag == 1:
        try:
            open(opts.quality_score_table)
        except:
            print "Quality score table cannot be opened or found! please double check your input."
            os._exit(1)
    elif opts.fasta_fastq_flag != None and opts.fasta_fastq_flag != 0 and opts.fasta_fastq_flag != 1:
        print "Incorrect input! The \"--fa_fq_flag\" parameter only accepts the input 0 or 1. Program will exit."
        os._exit(1)
    # check error adjust flag
    if opts.error_adjust_flag == None or opts.error_adjust_flag == 0:
        opts.error_adjust_flag = 0
    elif opts.error_adjust_flag == 1:
        if opts.error_rate == None:
            opts.error_rate = 0.001
    elif opts.error_adjust_flag != None and opts.error_adjust_flag != 0 and opts.error_adjust_flag != 1:
        print "Incorrect input! The \"--err_adj_flag\" parameter only accepts the input 0 or 1. Program will exit."
        os._exit(1)
    # check human flag
    if opts.human_flag == None or opts.human_flag == 0:
        opts.human_flag = 0
    elif opts.human_flag == 1:
        if opts.human_ref_folder == None:
            print "Human reference sequence folder must be provided if human reads are needed. Program will exit."
            os._exit(1)
        if opts.human_ratio == None:
            opts.human_ratio = 0.01
    elif opts.human_flag != None and opts.human_flag != 0 and opts.human_flag != 1:
        print "Incorrect input! The \"--h_flag\" parameter only accepts the input 0 or 1. Program will exit."
        os._exit(1)
    if opts.human_propor_table != None:
        genome_names = check_humanOrUnknown_index(opts.human_index)
        check_humanOrUnknown_propor_table(opts.human_propor_table, genome_names)
    # check unknown flag
    if opts.unknown_flag == None or opts.unknown_flag == 0:
        opts.unknown_flag = 0
    elif opts.unknown_flag == 1:
        if opts.human_ref_folder == None:
            print "Unknown reference sequence folder must be provided if human reads are needed. Program will exit."
            os._exit(1)
        if opts.unknown_ratio == None:
            opts.unknown_ratio = 0.01
    elif opts.unknown_flag != None and opts.unknown_flag != 0 and opts.unknown_flag != 1:
        print "Incorrect input! The \"--unk_flag\" parameter only accepts the input 0 or 1. Program will exit."
        os._exit(1)
    if opts.unknown_propor_table != None:
        genome_names = check_humanOrUnknown_index(opts.unknown_index)
        check_humanOrUnknown_propor_table(opts.unknown_propor_table, genome_names)    

    return opts

def read_genome_index(file_name):
    """
    Args:
        file_name:      str; microbial genome index file generated by microbe_index.py            
    """
    file_abs_paths, microbe_names = [], []
    genome_length_table = {}
    with open(file_name) as f_r:
        for line in f_r:
            line = line.strip().split('\t')
            file_abspath, microbe_name, genome_length = line[3], line[2], np.int(line[1])
            file_abs_paths.append(file_abspath)
            microbe_names.append(microbe_name)
            genome_length_table[microbe_name] = genome_length
    return file_abs_paths, microbe_names, genome_length_table

def read_humanOrUnknown_index(file_name):
    """
    Args:
        file_name:      str; Human (or unknown) sequence index file generated by humanOrUnknown_index.py            
    """
    h_unk_file_abs_paths, h_unk_names = [], []
    h_unk_genome_length_table = {}
    with open(file_name) as f_r:
        for line in f_r:
            line = line.strip().split('\t')
            file_abspath, name, genome_length = line[2], line[0], np.int(line[1])
            h_unk_file_abs_paths.append(file_abspath)
            h_unk_names.append(name)
            h_unk_genome_length_table[name] = genome_length
    return h_unk_file_abs_paths, h_unk_names, h_unk_genome_length_table

def read_proportion_table(file_name):
    """
    Args:
        file_name:      str; the proportion table file of the input microbial genomes
                        the file content format is like:
                            microbe_name_1    0.1
                            microbe_name_2    0.2
                            microbe_name_3    0.3
                            microbe_name_4    0.4
                        the sum of each microbial proportion should be equal to 1, you should notice that this program 
                        will not examine the validity of the sum of each microbial proportion                
    """
    proportion_table = {}
    with open(file_name) as f_r:
        for line in f_r:
            if line != '\n':
                line = line.strip().split()
                microbe_name, proportion = line[:-1], line[-1]
                microbe_name = ' '.join(microbe_name)
                proportion = np.float(proportion)
                proportion_table[microbe_name] = proportion
    return proportion_table

def adjust_proportion(propor_table, human_ratio, unknown_ratio, human_flag = 0, unknown_flag = 0):
    """
    Args:
        propor_table:   dict; a dict contains the proportion of each microbial genome
        human_ratio:    float; human reads ratio in the simulated metagenomic data
        unknown_ratio:  float; unknown microbial reads ratio in the simulated metagenomic data
        human_flag:     int; a 0-1 flag denotes whether human reads will be considered in the simulated 
                        metagenomic data, 0 means without consideration, 1 means with consideration, default
                        is 0
        unknown_flag:   int; a 0-1 flag denotes whether unknown microbial reads will be considered in the 
                        simulated metagenomic data, 0 means without consideration, 1 means with consideration, 
                        default is 0
    """
    microbe_ratio = 1.0                                             # only microbes                                         
    if human_flag == 1 and unknown_flag == 0:
        microbe_ratio = 1.0 - human_ratio                           # with human reads
    elif human_flag == 0 and unknown_flag == 1:
        microbe_ratio = 1.0 - unknown_ratio                         # with unknown microbial reads
    elif human_flag == 1 and unknown_flag == 1:
        microbe_ratio = (1.0 - human_ratio) * (1.0 - unknown_ratio) # with human and unknown microbial reads
        unknown_ratio *= 1.0 - human_ratio

    for microbe in propor_table:
        propor_table[microbe] *= microbe_ratio
    return propor_table, unknown_ratio

def cal_weighted_genome_length(microbe_names, propor_table, geo_len_table):
    """
    Args:
        microbe_names:  list; a list contains all of the microbe names of input microbial genomes
        propor_table:   dict; a dict contains the proportion of each microbial genome
        geo_len_table:  dict; a dict contains the length of each microbial genome
    """
    global tot_weighted_genome_length

    for microbe_name in microbe_names:
        if propor_table.has_key(microbe_name):
            propor = propor_table[microbe_name]
            geo_len = geo_len_table[microbe_name]
            tot_weighted_genome_length += propor * geo_len

def read_genome_distribution_table(file_name):
    """
    Args:
        file_name:      str; the genome distribution table file of the input genomes
                        the file content format is like:
                            microbe_name_1    1:10:100:1000:10000:100000
                            microbe_name_2    0.1:0.2:0.3:0.4
                            microbe_name_3    1:2:3:4:5:6:7:8:9:10
                            microbe_name_4    0.5:1.5:2.7:3.9:6.0:100.1
                        each line contains a microbe name and its corresponding genome distribution which can be obtained by
                        mapping the real metagenomic data to the genome                
    """
    distribution_table = {}
    with open(file_name) as f_r:
        for line in f_r:
            if line != '\n':
                line = line.strip().split()
                microbe_name, distribution = line[:-1], line[-1]
                microbe_name = ' '.join(microbe_name)
                distribution = distribution.split(':')
                distribution = np.array([np.float(num) for num in distribution])
                distribution_table[microbe_name] = distribution
    return distribution_table    

def read_quality_score_distribution(file_name, error_adjust_flag = 1, error_rate = 0.01):
    """
    Args:
        file_name:      str; the quality score distribution file generated by extract_quality_score_distribution.py                
        error_adjust_flag: int; a 0-1 flag denoting whether to control the overall error rate of the simulated 
                        reads, default is 1, means the overall error rate will be controled and the sequencing 
                        error probability at each base will be adjusted to make the overall error rate controllable
        error_rate:     float; overall error rate, will be used only if error_adjust_flag equals to 1
    """

    global visible_accurate_rate

    def check_intervaltree_package():
        try:
            import intervaltree
        except ImportError:
            os.system("pip install intervaltree")

    def cal_expected_err_prob(PROB_RANGE, qual_distri):
        # calculate the expected error probability of each base
        qual_distri_temp = [0] * len(qual_distri)
        qual_distri_temp[0] = qual_distri[0]
        for i in xrange(1, len(qual_distri)):
            qual_distri_temp[i] = qual_distri[i] - qual_distri[i - 1]
        qual_distri = np.array(qual_distri_temp)
        expected_err_prob = np.sum(PROB_RANGE * qual_distri)
        return expected_err_prob

    qual_score_tot_distri = {}
    expected_err_probs = []
    with open(file_name) as f_r:
        f_r.readline()    # ignore the first annotation line
        encoding_base = np.int(f_r.readline().strip().split('=')[-1])
        encode_min, encode_max = f_r.readline().strip().split('=')[-1].split('-')
        encode_min, encode_max = np.int(encode_min), np.int(encode_max)
        QUAL_RANGE = np.arange(encode_min, encode_max + 1)
        PROB_RANGE = np.power(10, -0.1 * QUAL_RANGE)
        max_read_length = np.int(f_r.readline().strip().split('=')[-1])
        check_intervaltree_package()
        import intervaltree
        for line in f_r:
            pos, qual_distri = line.strip().split('\t')
            pos = np.int(pos.split('_')[-1])
            qual_distri = [np.float(s) for s in qual_distri.split(':')]
            expected_err_prob = cal_expected_err_prob(PROB_RANGE, qual_distri)
            expected_err_probs.append(expected_err_prob)
            interval_tree = intervaltree.IntervalTree()
            interval_tree.addi(0, qual_distri[0], encode_min)
            for i in xrange(encode_min + 1, encode_max + 1):
                interval_tree.addi(qual_distri[i - 1], qual_distri[i], i)
            qual_score_tot_distri[pos] = interval_tree
        visible_accurate_rate = np.array([1] * max_read_length, dtype = np.float)
        if error_adjust_flag == 1:
            for i in xrange(len(expected_err_probs)):
                # if error_rate > expected_err_probs[i]:
                visible_accurate_rate[i] = (1.0 - error_rate) / (1.0 - expected_err_probs[i])
    return qual_score_tot_distri, encoding_base, max_read_length

def read_genome(file_name):
    """
    Args:
        file_name:      str; the genome file, it should only contains a single complete sequence
                        the file format is .fna (using .fa for short), which contains:
                            >U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome
                            ATCGAGTCAGTCAGTCGATCG...
                            CAGTCACGATAGTATCGGTCG...
                            GTCAGCAAGTCTCGATCGAGT...                
    """
    annotation = ""
    genome = []
    with open(file_name) as f_r:
        annotation = f_r.readline().strip()        # e.g., >U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome
        for line in f_r:
            genome.extend(line.strip())
    genome = ''.join(genome)
    return annotation, genome

def read_human_chromosome(file_path, human_ratio, propor_table):
    """
    Args:
        file_path:      str; a string denotes the human reference genome path
        human_ratio:    float; human reads ratio in the simulated metagenomic data
        propor_table:   dict; a dict contains the proportion of each human chromosome
    """
    global tot_weighted_genome_length

    file_path = file_path.rstrip('/') + '/'
    file_abs_paths = []
    file_names = os.listdir(file_path)
    human_ref_num = len(file_names)
    annotation = ""
    propor_table_output = {}
    for file_ in file_names:
        file_name = file_path + file_
        file_abs_paths.append(file_name)
        chromosome = []
        with open(file_name) as f_r:
            annotation = f_r.readline().strip()
            for line in f_r:
                chromosome.extend(line.strip())
        chromosome = ''.join(chromosome)
        human_genome_ratio = 0.0
        name = annotation.lstrip('>').split(' ', 1)[0]
        if propor_table:
            human_genome_ratio = human_ratio * propor_table[name]
        elif not propor_table:
            human_genome_ratio = human_ratio * 1.0 / np.float(human_ref_num)
            propor_table_output[name] = 1.0 / np.float(human_ref_num)
        tot_weighted_genome_length += human_genome_ratio * len(chromosome)

    if propor_table:
        propor_table_output = propor_table

    return file_abs_paths, propor_table_output

def read_unknown_genome(file_path, unknown_ratio, propor_table):
    """
    Args:
        file_path:       str; a string denotes the unknown microbial genome
        unknown_ratio:   float; unknown reads ratio in the simulated metagenomic data
        propor_table:    dict; a dict contains the proportion of each unknown reference sequence
    """
    global tot_weighted_genome_length

    file_path = file_path.rstrip('/') + '/'
    file_abs_paths = []
    file_names = os.listdir(file_path)
    unknown_genome_ref_num = len(file_names)
    annotation = ""
    propor_table_output = {}
    for file_ in file_names:
        file_name = file_path + file_
        file_abs_paths.append(file_name)
        unknown_genome = []
        with open(file_name) as f_r:
            annotation = f_r.readline().strip()
            for line in f_r:
                unknown_genome.extend(line.strip())
        unknown_genome = ''.join(unknown_genome)
        unknown_genome_ratio = 0.0
        name = annotation.lstrip('>').split(' ', 1)[0]
        if propor_table:
            unknown_genome_ratio = unknown_ratio * propor_table[name]
        elif not propor_table:
            unknown_genome_ratio = unknown_ratio * 1.0 / np.float(unknown_genome_ref_num)
            propor_table_output[name] = 1.0 / np.float(unknown_genome_ref_num)
        tot_weighted_genome_length += unknown_genome_ratio * len(unknown_genome)

    if propor_table:
        propor_table_output = propor_table

    return file_abs_paths, propor_table_output

def read_one_human_chromosome(file_path):
    annotation = ""
    chromosome = []
    with open(file_path) as f_r:
        annotation = f_r.readline().strip()    
        for line in f_r:
            chromosome.extend(line.strip())
    chromosome = ''.join(chromosome)
    return annotation, chromosome

def read_one_unknown_genome(file_path):
    annotation = ""
    unknown_genome = []
    with open(file_path) as f_r:
        annotation = f_r.readline().strip()    
        for line in f_r:
            unknown_genome.extend(line.strip())
    unknown_genome = ''.join(unknown_genome)
    return annotation, unknown_genome

def gen_quality_score(qual_distri, encoding_base, reads_length):
    """
    Args:
        qual_distri:    dict; a dict contains the quality score distribution of each position of a read
        encoding_base:  int; the encoding method of the quality score
        reads_length:   int; read length of one read
    """
    import intervaltree
    qual_score_str = ""
    qual_score_samples = np.random.uniform(0, 1, reads_length)
    qual_score_list = []
    for i in xrange(reads_length):
        score = list(qual_distri[i].search(qual_score_samples[i]))[0].data
        qual_score_list.append(score)
        ascii_code = score + encoding_base
        char = chr(ascii_code)
        qual_score_str += char
    return qual_score_str, qual_score_list

# base substitution probability matrix            #   A G C T
Smatrix = np.array([(0, 1.0/3, 1.0/3, 1.0/3),    # A
                    (1.0/3, 0, 1.0/3, 1.0/3),   # G
                    (1.0/3, 1.0/3, 0, 1.0/3),   # C
                    (1.0/3, 1.0/3, 1.0/3, 0)])  # T

def CALL_posVaried_decorate_reads(genome, start_site, end_site, qual_score_list, error_adjust_flag = 1, error_rate = 0.01,
                                  sub_prob = 0.999, sub_matrix = Smatrix, del_prob = 0.0005, ins_prob = 0.0005):
    """
    Args:
        genome:         str; a string denotes the genome, like 'ATCGACTGAA...'
        start_site:     int; read begining position
        end_site:       int; read termination position
        qual_score_list:list; numeric quality score of one read
        error_adjust_flag: int; a 0-1 flag denoting whether to control the overall error rate of the simulated 
                        reads, default is 1, means the overall error rate will be controled and the sequencing 
                        error probability at each base will be adjusted to make the overall error rate controllable
        error_rate:     float; overall error rate, will be used only if error_adjust_flag equals to 1
        sub_prob:       float; the relative proportion of substitution
        sub_matrix:     np.array; substitution probability matrix, note that the sum of each row or column
                        in this matrix shall be one.
        del_prob:       float; the relative proportion of deletion
        ins_prob:       float; the relative proportion of insertion
    """

    raw_seq = genome[start_site:end_site + 1]
    decorated_seq = raw_seq.upper()
    seq_len = len(decorated_seq)
    op_annotation = ''      # a string recording the conducted operations (insertion/deletion/substitution) as
                            # an annotation identifier in the final generated annotation
    operation_stat = ''     # a string recording the conducted operation on each base in a read

    def substitution(sub_matrix, original):
        # base substitution operation
        if original == 'A':
            ori = 0
        elif original == 'G':
            ori = 1
        elif original == 'C':
            ori = 2
        else:
            ori = 3                       # base 'T'
        dice = np.random.uniform(0, 1)
        if dice < sub_matrix[ori][0]:    
            return 'A'                    # sub to A
        elif dice < sub_matrix[ori][0] + sub_matrix[ori][1]:
            return 'G'                    # sub to G
        elif dice < sub_matrix[ori][0] + sub_matrix[ori][1] + sub_matrix[ori][2]:  
            return 'C'                    # sub to C
        else:  
            return 'T'

    def insertion():
        # base insertion operation
        return random.sample("AGCT", 1)[0]

    global visible_accurate_rate
    # generate operation record annotation
    for idx in xrange(seq_len):
        qual_score_induced_prob = np.power(10, -0.1 * qual_score_list[idx])
        adjusted_err_prob = qual_score_induced_prob
        if error_adjust_flag == 1: 
            adjusted_err_prob = 1.0 - visible_accurate_rate[idx] * (1.0 - qual_score_induced_prob)
            if adjusted_err_prob > error_rate or adjusted_err_prob < 0:
                adjusted_err_prob = error_rate
        error_indicator = np.random.uniform(0, 1)
        if error_indicator < adjusted_err_prob:
            dice = np.random.uniform(0, 1)
            if dice < sub_prob:    
                operation_stat += 'S'            # apply substitution
            elif dice < sub_prob + del_prob:  
                operation_stat += 'D'            # apply deletion
            else:  
                operation_stat += 'I'            # apply insertion
        else:              
            operation_stat += 'N'            # no operation, normal base

    # generate substitution and deletion based on operation record annotation
    for idx in xrange(seq_len):
        if operation_stat[idx] == 'S' or operation_stat[idx] == 'D':
            head = decorated_seq[:idx]
            if operation_stat[idx] == 'S':
                mid = substitution(sub_matrix, decorated_seq[idx])
                op_annotation += '|' + str(start_site + idx) + decorated_seq[idx] + mid # format: substitution position + original + mutated
            else:
                mid = 'D'
                op_annotation += '|' + str(start_site + idx) + '-' + decorated_seq[idx]    # format: substitution position + '-' + mutated
            tail = decorated_seq[(idx + 1):]
            decorated_seq = head + mid + tail
    # generate insertion based on operation record annotation
    inserted = [''] * seq_len
    for idx in xrange(seq_len - 1):        # notice that insertion at the last position of a read will be ignored
        if operation_stat[idx] == 'I':
            head = decorated_seq[0: idx + 1]
            tail = decorated_seq[idx + 1:]
            inserted[idx] = insertion() # log the insertion element
            op_annotation += '|' + str(start_site+idx) + '+' + inserted[idx]          # format: substitution position + '+' + mutated
    temp = ''
    for idx in xrange(seq_len):
        temp += decorated_seq[idx] + inserted[idx]
    decorated_seq = temp

    # post-processing for deletion
    del_cnt = decorated_seq.count('D')
    if end_site + 1 < len(genome):
        append = genome[(end_site + 1):(end_site + del_cnt + 1)]
    else:
        append = ''
        while del_cnt:
            del_cnt -= 1
            append += insertion()
    decorated_seq = decorated_seq + append
    decorated_seq = re.sub('D', '', decorated_seq)
    decorated_seq = decorated_seq[:seq_len]
    return (op_annotation, decorated_seq)

def gen_nonuniform_distribution_reads(genome, reads_num, reads_length, bin_size, 
                                      distribution, dis_args, user_def_dis):
    """
    Args:
        genome:         str; a string denotes the genome, like 'ATCGACTGAA...'
        reads_num:      int; the reads number obtained from the input one genome
        reads_length:   int; the length of each reads, here only the fixed read length is used
        bin_size:       int; the size of the bins in the input genome, in order to seperate the genome
                        into several bins and assign different probabilities of each bin, to imitate a
                        non-uniform probability distribution to extract the reads from the input genome
        distribution:   np.random.method; a distribution method in numpy.random module to generate random  
                        numbers as the proportion of each bin in the output (numbers which are negative will 
                        be turned into positive, e.g., for the random numbers generated by normal distribution)
        dis_args:       list; the corresponding arg list of the input distribution method (except the size),
                        like the np.random.uniform method, the distri_args will be [mu, sigma] 
        user_def_dis:   np.array; a user defined distribution, e.g., np.array([0.1, 0.2, 0.3, 0.4, 0.5]), 
                        this one will be used if given and the above three parameters "distribution, 
                        dis_args" will be ignored, also the bin size will depend on the length
                        of user_def_dis
    """
    propor = np.array([])
    genome_len = len(genome)
    n_bins = 0
    if len(user_def_dis) != 0:
        propor = user_def_dis
        n_bins = len(user_def_dis)
        bin_size = genome_len / n_bins
    else:
        n_bins = np.int(np.ceil(genome_len / np.float(bin_size)))
        # check whether the input distribution method is available or not 
        distributions = {np.random.uniform: None, np.random.normal: None, np.random.exponential: None}
        try:
            assert distributions.has_key(distribution) == True
        except Exception, e:
            print "The input distribution method is not available in this function."

        # generate random numbers as the proportion of each bin
        if distribution == np.random.uniform:
            propor = np.sum(distribution(dis_args[0], dis_args[1], n_bins)) / n_bins
            propor = [propor for i in xrange(n_bins)]
            propor = np.array(propor)
        elif distribution == np.random.normal:
            propor = distribution(dis_args[0], dis_args[1], n_bins)
            propor.sort()
        elif distribution == np.random.exponential:
            propor = distribution(dis_args[0], n_bins)
            propor.sort()
            propor = propor[::-1]
        propor = np.abs(propor)

    # divide the postions of the input genome into position buckets according to bins, the last position
    # bucket should be treated separately because it may not have the same length of other buckets in pos_buckets
    pos_buckets = np.array([i for i in xrange(bin_size)])
    for i in xrange(1, n_bins - 1):
        pos_buckets = np.vstack((pos_buckets, np.array([j for j in xrange(i * bin_size, (i + 1) * bin_size)])))
    last_pos_bucket = np.array([])
    # If the length of last bucket is shorter than reads_length, then discard it cause it is not
    # long enough for reads generation
    if (genome_len - (n_bins - 1) * bin_size) > reads_length:
        last_pos_bucket = np.array([i for i in xrange((n_bins - 1) * bin_size, genome_len - reads_length)])

    # zip propor_cum and pos_buckets to a dict
    propor_cum = np.array([])
    propor_pos_buckets = {}
    if len(last_pos_bucket) == 0:
        propor = propor[:-1]
        propor_cum = propor.cumsum()
        propor_pos_buckets = dict(zip(propor_cum, pos_buckets))
    else:
        propor_cum = propor.cumsum()
        propor_pos_buckets = dict(zip(propor_cum[:len(propor_cum) - 1], pos_buckets))
        propor_pos_buckets[propor_cum[len(propor_cum) - 1]] = last_pos_bucket
    
    # calculate the sample points in each bin, then sort them and assign them into their corresponding bins
    pseudo_sample_points = np.random.uniform(0, 1, reads_num) * np.sum(propor)
    pseudo_sample_points.sort()

    # extract the sampled reads using the position information and the input reads_length
    count = 0
    sample_points = []
    for i in xrange(len(pseudo_sample_points)):
        if pseudo_sample_points[i] > propor_cum[count]:
            count += 1
        sample_point = np.random.choice(propor_pos_buckets[propor_cum[count]])
        sample_points.append(sample_point)
    return sample_points

def write_reads_fasta(genome, annotation, sample_points, reads_length, file_name_write):
    """
    Args:
        genome:         str; a string denotes the genome, like 'ATCGACTGAA...'
        annotation:     str; an annotation string extracted from the genome file
        sample_points:  list; a list contains sample points on the genome generated by 
                        function "gen_nonuniform_distribution_reads"
        reads_length:   int; the length of each reads, here only the fixed read length is used
        file_name_write:str; the prefix of the generated reads file, no sufix (representing the file format) 
                        is required, the file format will be .fasta (using .fa for short), it is like:
                            >U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome|start_site1:end_site1
                            ATCGAGTCAGTCAGTCGATCG...
                            >U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome|start_site2:end_site2
                            CAGTCACGATAGTATCGGTCG...
                            ...
                            >U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome|start_siten:end_siten
                            GTCAGCAAGTCTCGATCGAGT...
    """
    file_name_write = file_name_write + ".fa"
    with open(file_name_write, 'a') as f_w:
        for i in xrange(len(sample_points)):
            start_site = sample_points[i]
            end_site = sample_points[i] + reads_length - 1
            one_read = genome[start_site:end_site + 1]
            annot = annotation + '|' + str(start_site) + ':' + str(end_site)
            f_w.write(annot)
            f_w.write('\n')
            f_w.write(one_read)
            f_w.write('\n')

def write_reads_fastq(genome, annotation, sample_points, qual_distri, encoding_base, reads_length, file_name_write, error_adjust_flag = 1, error_rate = 0.01):
    """
    Args:
        genome:         str; a string denotes the genome, like 'ATCGACTGAA...'
        annotation:     str; an annotation string extracted from the genome file
        sample_points:  list; a list contains sample points on the genome generated by 
                        function "gen_nonuniform_distribution_reads"
        qual_distri:    dict; a dict contains the quality score distribution of each position of a read
        encoding_base:  int; the encoding method of the quality score
        reads_length:   int; the length of each reads, here only the fixed read length is used
        file_name_write:str; the prefix of the generated reads file, no sufix (representing the file format) 
                        is required, the file format will be .fastq (using .fq for short), it is like:
                            @>U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome|start_site1:end_site1
                            ATCGAGTCAGTCAGTCGATCG...
                            +
                            abbeeehhiiihiiiiecgii...
                            @>U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome|start_site2:end_site2
                            CAGTCACGATAGTATCGGTCG...
                            +
                            gcggiiihhghiiieghhiii...
                            ...
                            @>U00096.3 Escherichia coli str. K-12 substr. MG1655, complete genome|start_siten:end_siten
                            GTCAGCAAGTCTCGATCGAGT...
                            +
                            iigiihhghiiiebbeeehhi...
        error_adjust_flag: int; a 0-1 flag denoting whether to control the overall error rate of the simulated 
                        reads, default is 1, means the overall error rate will be controled and the sequencing 
                        error probability at each base will be adjusted to make the overall error rate controllable
        error_rate:     float; overall error rate, will be used only if error_adjust_flag equals to 1
    """
    file_name_write = file_name_write + ".fq"
    with open(file_name_write, 'a') as f_w:
        for i in xrange(len(sample_points)):
            start_site = sample_points[i]
            end_site = sample_points[i] + reads_length - 1
            qual_score_str, qual_score_list = gen_quality_score(qual_distri, encoding_base, reads_length)
            (decorated_annot, decorated_read) = CALL_posVaried_decorate_reads(genome, start_site, end_site, qual_score_list, error_adjust_flag, error_rate)
            annot = '@' + annotation + '|' + str(start_site) + ':' + str(end_site) + decorated_annot
            f_w.write(annot)
            f_w.write('\n')
            f_w.write(decorated_read)
            f_w.write('\n')
            f_w.write('+')
            f_w.write('\n')
            f_w.write(qual_score_str)
            f_w.write('\n')

def gen_reads_from_multiple_genomes(geo_file_paths, microbe_names, file_name_write, propor_table, tot_reads_num,  
                                    reads_length = 101, bin_size = 2000, distribution = np.random.uniform, 
                                    dis_args = [0, 1], distri_table = {}, fa_fq_flag = 0, qual_distri = {}, 
                                    encoding_base = 33, error_adjust_flag = 1, error_rate = 0.01):
    """
    Args:
        geo_file_paths: list; a list contains all of the absolute paths of the input microbial genomes         
        microbe_names:  list; a list contains all of the microbe names of input microbial genomes
        file_name_write:str; a string denotes the absolute path to save the generated reads file,
                        just the output file prefix is needed, no sufix (file format) is required, 
        propor_table:   dict; a dict contains the proportion of each microbial genome
        tot_reads_num:  int; the total reads number to be generated
        reads_length:   int; the length of each reads, here only the fixed read length is used
        bin_size:       int; the size of the bins in the input genomes, in order to seperate the genomes
                        into several bins and assign different probabilities of each bin, to imitate a
                        non-uniform probability distribution to extract the reads from the input genomes
        distribution:   np.random.method; a distribution method in numpy.random module to generate random  
                        numbers as the proportion of each bin in the output (numbers which are negative will 
                        be turned into positive, e.g., for the random numbers generated by normal distribution)    
        dis_args:       list; the corresponding arg list of the input distribution method (except the size),
                        like the np.random.uniform method, the distri_args will be [mu, sigma]   
        distri_table:   dict; a user input genomes' distribution table, e.g.:
                            {
                                "microbe_name_1": np.array([1, 10, 100, 1000, 10000, 100000]), 
                                "microbe_name_2": np.array([0.1, 0.2, 0.3, 0.4]),
                                "microbe_name_3": np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
                                "microbe_name_4": np.array([0.5, 1.5, 2.7, 3.9, 6.0, 100.1])     
                            }
                        this one will be used if given and the above four parameters "distribution, dis_args" will be 
                        ignored, also the bin size will depend on the length of the genome distribution (formatted by 
                        np.array([])) in each dict's item
        fa_fq_flag:     int; a 0-1 flag denotes whether the reads file format to be generated is fasta or fsatq, 
                        0 means fasta and 1 means fastq, default is 0
        qual_distri:    dict; a dict contains the quality score distribution of each position of a read
        encoding_base:  int; the encoding method of the quality score
        error_adjust_flag: int; a 0-1 flag denoting whether to control the overall error rate of the simulated 
                        reads, default is 1, means the overall error rate will be controled and the sequencing 
                        error probability at each base will be adjusted to make the overall error rate controllable
        error_rate:     float; overall error rate, will be used only if error_adjust_flag equals to 1
    """
    global tot_weighted_genome_length
    global SIMU_INFO

    for i in xrange(len(geo_file_paths)):
        annotation, genome = read_genome(geo_file_paths[i])
        genome_len = len(genome)
        genome_reads_num = 0
        if propor_table.has_key(microbe_names[i]):
            genome_reads_num = np.int(np.round(tot_reads_num * (propor_table[microbe_names[i]] * genome_len / tot_weighted_genome_length)))
        if genome_reads_num < 1:
            genome_reads_num = 1
        user_def_dis = np.array([])
        ################### WRITE SIMULATE META INFO ###################
        seq_depth = genome_reads_num * reads_length / np.float(genome_len)
        write_line = annotation.lstrip('>') + '\t' + str(genome_len) + '\t' + str(genome_reads_num) + '\t' + str(seq_depth)
        SIMU_INFO.write(write_line)
        SIMU_INFO.write('\n')
        ################################################################
        if len(distri_table) != 0:
            user_def_dis = distri_table[microbe_names[i]]
        sample_points = gen_nonuniform_distribution_reads(genome, genome_reads_num, reads_length, bin_size, 
                                                          distribution, dis_args, user_def_dis)
        if fa_fq_flag == 1:
            write_reads_fastq(genome, annotation, sample_points, qual_distri, encoding_base, reads_length, file_name_write, error_adjust_flag, error_rate)
        else: 
            write_reads_fasta(genome, annotation, sample_points, reads_length, file_name_write)
        SIMU_INFO.flush()

def gen_human_reads(chromosome, annotation, tot_reads_num, reads_length, human_ratio, propor_table, human_paths):
    """
    Args: 
        chromosome:     str; a string denotes the human chromosome
        annotation:     str; an annotation string extracted from the human chromosome file        
        tot_reads_num:  int; the total reads number to be generated
        reads_length:   int; the length of each reads, here only the fixed read length is used
        human_ratio:    float; human reads ratio in the simulated metagenomic data
        propor_table:   dict; a dict contains the proportion of each human chromosome
        human_paths:    list; a list contains all the human reference sequence storage path
    """
    global tot_weighted_genome_length
    global SIMU_INFO

    human_ref_num = len(human_paths)
    chr_len = len(chromosome)
    human_reads_num = 0
    name = annotation.lstrip('>').split(' ', 1)[0]
    human_genome_ratio = human_ratio * propor_table[name]
    human_reads_num = np.int(np.round(tot_reads_num * (human_genome_ratio * chr_len / tot_weighted_genome_length)))
    if human_reads_num < 1:
        human_reads_num = 1
    ################### WRITE SIMULATE META INFO ###################
    seq_depth = human_reads_num * reads_length / np.float(chr_len)
    write_line = annotation.lstrip('>') + '\t' + str(chr_len) + '\t' + str(human_reads_num) + '\t' + str(seq_depth)
    SIMU_INFO.write(write_line)
    SIMU_INFO.write('\n')
    SIMU_INFO.flush()
    ################################################################
    sample_points = np.random.uniform(0, 1, human_reads_num) * (chr_len - reads_length)
    sample_points = np.array(sample_points, dtype = np.int)
    return sample_points

def gen_unknown_reads(unknown_genome, annotation, tot_reads_num, reads_length, unknown_ratio, propor_table, unknown_paths):
    """
    Args: 
        unknown_genome: str; a string denotes the unknown genome
        annotation:     str; an annotation string extracted from the unknown genome file        
        tot_reads_num:  int; the total reads number to be generated
        reads_length:   int; the length of each reads, here only the fixed read length is used
        unknown_ratio:  float; unknown reads ratio in the simulated metagenomic data
        propor_table:   dict; a dict contains the proportion of each unknown reference sequence
        unknown_paths:  list; a list contains all the unknown reference sequence storage path
    """
    global tot_weighted_genome_length
    global SIMU_INFO

    unk_ref_num = len(unknown_paths)
    unk_len = len(unknown_genome)
    unknown_reads_num = 0
    name = annotation.lstrip('>').split(' ', 1)[0]
    unknown_genome_ratio = unknown_ratio * propor_table[name]       
    unknown_reads_num = np.int(np.round(tot_reads_num * (unknown_genome_ratio * unk_len / tot_weighted_genome_length)))
    if unknown_reads_num < 1:
        unknown_reads_num = 1
    ################### WRITE SIMULATE META INFO ###################
    seq_depth = unknown_reads_num * reads_length / np.float(unk_len)
    write_line = annotation.lstrip('>') + '\t' + str(unk_len) + '\t' + str(unknown_reads_num) + '\t' + str(seq_depth)
    SIMU_INFO.write(write_line)
    SIMU_INFO.write('\n')
    SIMU_INFO.flush()
    ################################################################    
    sample_points = np.random.uniform(0, 1, unknown_reads_num) * (unk_len - reads_length)
    sample_points = np.array(sample_points, dtype = np.int)
    return sample_points

def main():
    opts = argvParse()
    opts = argvCheck(opts)

    index_file_path = opts.index_file
    propor_table_path = opts.propor_table
    file_name_write = opts.file_name_write
    tot_reads_num = opts.read_number
    reads_length = opts.read_length
    var_seed_flag = opts.var_seed_flag
    random_seed = opts.random_seed
    distribution_use_flag = opts.distribution_use_flag
    bin_size = opts.bin_size
    distribution_table_path = opts.distribution_table
    distribution = opts.distribution_name
    dis_args = opts.distribution_args
    fa_fq_flag = opts.fasta_fastq_flag
    quality_score_path = opts.quality_score_table
    error_adjust_flag = opts.error_adjust_flag
    error_rate = opts.error_rate
    human_flag = opts.human_flag
    human_ref_path = opts.human_ref_folder
    human_ratio = opts.human_ratio
    human_index = opts.human_index
    human_propor_table_path = opts.human_propor_table
    unknown_flag = opts.unknown_flag
    unknown_genome_path = opts.unknown_ref_folder
    unknown_ratio = opts.unknown_ratio
    unknown_index = opts.unknown_index
    unknown_propor_table_path = opts.unknown_propor_table

    # set a global fixed random seed if needed
    if var_seed_flag == 0:
        np.random.seed(random_seed)
        random.seed(random_seed)
    else:
        import time
        np.random.seed(np.int(time.time()))
        random.seed(np.int(time.time()))

    # create a file to save the annotation, genome length, generated reads number and sequencing depth
    # of each used genome
    global SIMU_INFO
    SIMU_INFO = open(file_name_write + "_simuInfo.txt", 'w')
    write_line = "#genome annotation\tgenome length\treads number\tsequencing depth"
    SIMU_INFO.write(write_line)
    SIMU_INFO.write('\n')
    SIMU_INFO.flush()

    # initialize the distribution_table and qual_score_distri
    distribution_table = {}
    if fa_fq_flag == 0:
        qual_score_distri = {}

    # necessary profiles loading
    file_abs_paths, microbe_names, genome_length_table = read_genome_index(index_file_path)
    propor_table = read_proportion_table(propor_table_path)
    propor_table, unknown_ratio = adjust_proportion(propor_table, human_ratio, unknown_ratio, human_flag, unknown_flag)
    cal_weighted_genome_length(microbe_names, propor_table, genome_length_table)
    if distribution_use_flag == 1:
        distribution_table = read_genome_distribution_table(distribution_table_path)

    # optional profiles loading
    human_file_abs_paths, human_names, human_genome_length_table, human_propor_table = [], [], {}, {}
    if human_flag == 1:     
        if human_index != None:
            human_file_abs_paths, human_names, human_genome_length_table = read_humanOrUnknown_index(human_index)
            if human_propor_table_path != None:
                human_propor_table = read_proportion_table(human_propor_table_path)
    unknown_file_abs_paths, unknown_names, unknown_genome_length_table, unknown_propor_table = [], [], {}, {}
    if unknown_flag == 1:
        if unknown_index != None:
            unknown_file_abs_paths, unknown_names, unknown_genome_length_table = read_humanOrUnknown_index(unknown_index)
            if unknown_propor_table_path != None:
                unknown_propor_table = read_proportion_table(unknown_propor_table_path)

    # add human or unknown reads to the generated simulted reads if needed
    chr_annot, chromosome = "", ""
    human_sample_points = []
    if human_flag == 1:
        human_file_abs_paths, human_propor_table = read_human_chromosome(human_ref_path, human_ratio, human_propor_table)
    unk_annot, unknown_genome = "", ""
    unknown_sample_points = []
    if unknown_flag == 1:
        unknown_file_abs_paths, unknown_propor_table = read_unknown_genome(unknown_genome_path, unknown_ratio, unknown_propor_table)

    # generate simulated reads
    if fa_fq_flag == 1:
        if error_adjust_flag == 1:
            qual_score_distri, encoding_base, max_read_length = read_quality_score_distribution(quality_score_path, error_adjust_flag, error_rate)
        elif error_adjust_flag == 0:
            qual_score_distri, encoding_base, max_read_length = read_quality_score_distribution(quality_score_path, error_adjust_flag)
        if reads_length > max_read_length:
            print ("Warning! The input read length is longer than that reading from 'quality_score.txt' file. "
                   "Now the program will use the read length in 'quality_score.txt' file instead")
            reads_length = max_read_length
        gen_reads_from_multiple_genomes(file_abs_paths, microbe_names, file_name_write, propor_table, tot_reads_num,  
                                        reads_length, bin_size, distribution, dis_args, distribution_table, 
                                        fa_fq_flag, qual_score_distri, encoding_base, error_adjust_flag, error_rate)
        if human_flag == 1 and unknown_flag == 0:
            for human_path in human_file_abs_paths:
                chr_annot, chromosome = read_one_human_chromosome(human_path)
                human_sample_points = gen_human_reads(chromosome, chr_annot, tot_reads_num, reads_length, human_ratio, human_propor_table, human_file_abs_paths)
                write_reads_fastq(chromosome, chr_annot, human_sample_points, qual_score_distri, encoding_base, reads_length, file_name_write, error_adjust_flag, error_rate)
        elif human_flag == 0 and unknown_flag == 1:
            for unknown_path in unknown_file_abs_paths:
                unk_annot, unknown_genome = read_one_unknown_genome(unknown_path)
                unknown_sample_points = gen_unknown_reads(unknown_genome, unk_annot, tot_reads_num, reads_length, unknown_ratio, unknown_propor_table, unknown_file_abs_paths)
                write_reads_fastq(unknown_genome, unk_annot, unknown_sample_points, qual_score_distri, encoding_base, reads_length, file_name_write, error_adjust_flag, error_rate)            
        elif human_flag == 1 and unknown_flag == 1:
            for human_path in human_file_abs_paths:
                chr_annot, chromosome = read_one_human_chromosome(human_path)
                human_sample_points = gen_human_reads(chromosome, chr_annot, tot_reads_num, reads_length, human_ratio, human_propor_table, human_file_abs_paths)                
                write_reads_fastq(chromosome, chr_annot, human_sample_points, qual_score_distri, encoding_base, reads_length, file_name_write, error_adjust_flag, error_rate)
            for unknown_path in unknown_file_abs_paths:
                unk_annot, unknown_genome = read_one_unknown_genome(unknown_path)
                unknown_sample_points = gen_unknown_reads(unknown_genome, unk_annot, tot_reads_num, reads_length, unknown_ratio, unknown_propor_table, unknown_file_abs_paths)                
                write_reads_fastq(unknown_genome, unk_annot, unknown_sample_points, qual_score_distri, encoding_base, reads_length, file_name_write, error_adjust_flag, error_rate)                        
    else:
        gen_reads_from_multiple_genomes(file_abs_paths, microbe_names, file_name_write, propor_table, tot_reads_num,  
                                        reads_length, bin_size, distribution, dis_args, distribution_table)
        if human_flag == 1 and unknown_flag == 0:
            for human_path in human_file_abs_paths:
                chr_annot, chromosome = read_one_human_chromosome(human_path)
                human_sample_points = gen_human_reads(chromosome, chr_annot, tot_reads_num, reads_length, human_ratio, human_propor_table, human_file_abs_paths)          
                write_reads_fasta(chromosome, chr_annot, human_sample_points, reads_length, file_name_write)
        elif human_flag == 0 and unknown_flag == 1:
            for unknown_path in unknown_file_abs_paths:
                unk_annot, unknown_genome = read_one_unknown_genome(unknown_path)
                unknown_sample_points = gen_unknown_reads(unknown_genome, unk_annot, tot_reads_num, reads_length, unknown_ratio, unknown_propor_table, unknown_file_abs_paths)            
                write_reads_fasta(unknown_genome, unk_annot, unknown_sample_points, reads_length, file_name_write)
        elif human_flag == 1 and unknown_flag == 1:
            for human_path in human_file_abs_paths:
                chr_annot, chromosome = read_one_human_chromosome(human_path)
                human_sample_points = gen_human_reads(chromosome, chr_annot, tot_reads_num, reads_length, human_ratio, human_propor_table, human_file_abs_paths)                     
                write_reads_fasta(chromosome, chr_annot, human_sample_points, reads_length, file_name_write)
            for unknown_path in unknown_file_abs_paths:
                unk_annot, unknown_genome = read_one_unknown_genome(unknown_path)
                unknown_sample_points = gen_unknown_reads(unknown_genome, unk_annot, tot_reads_num, reads_length, unknown_ratio, unknown_propor_table, unknown_file_abs_paths)                        
                write_reads_fasta(unknown_genome, unk_annot, unknown_sample_points, reads_length, file_name_write)

    # close the SIMU_INFO file
    SIMU_INFO.close()

if __name__ == '__main__':
    main()
